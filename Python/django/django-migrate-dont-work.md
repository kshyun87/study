# Django Mirgate Don't create Table
장고(Django)는 db 컨트롤까지 제공되어 model을 만드는 것만으로도 테이블을 생성해주는 좋은 녀석이다.
잘 사용하기 위해서는 makemigrations와 migrate를 잘 사용해야한다.

처음 단순히 모델 생성하거나 변경한 내용을 적용시켜주는 줄 알았는데 알고보니 RDMBS에서 사용하느 롤백 기능과 같이 롤백도 가능한 것을 알게 되었다.

또한 실수로 DB에서 직접적으로 테이블을 날려(삭제)버리는 경우에 테이블을 새로 생성해야하는데 제대로 되지 않을 경우가 있어서 그 해결 방법을 적어본다.

## makemigrations?
말 그대로 병합을 만든다는 의미이다.
즉 DB에 적용시킬 분기점을 생성시켜준다는 것으로 SQL문을 만들어주는 역할이라고 할 수 있다.
단순히 장고에서 model.py에 적용되어진 부분을 DB에 적용할 수 있는 문서로 만드는 작업이다.

가령 model.py에서
```python
class ModelA(models.Model):
    id = SmallUUIDField(primary_key=True, default=uuid_default())
    name = models.CharField(max_length=100, blank=False, null=False)

    def __str__(self):
        return self.name
```
위와 같이 작성을 하자.
이 모델은 ModelA라고 한다. (영문으로 표기하기 바람)
ModelA는 아이디와 이름을 가진 테이블로 만들어야한다.
SQL로 치면 CREATE TABLE ~~어쩌구 저쩌구 하면서 작성해서 실행해야한다.
그러나 장고는 그런 귀찮음을 해결해주는데 그게 바로 makemigrations이다.

```bash
python manage.py makemigrations
```
이렇게 명령어를 입력하면 자동으로 모델 정보가 변경된 내용을 반영해서 문서로 만들어준다.

아래는 그 결과다. 참고로 migration문서는 해당 app의 migrations폴더에 존재한다.
```python
# -*- coding: utf-8 -*-
# Generated by Django 1.11.2 on 2018-01-08 04:18
from __future__ import unicode_literals

from django.db import migrations, models
import django.db.models.deletion
import django_smalluuid.models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='ModelA',
            fields=[
                ('id', django_smalluuid.models.SmallUUIDField(default=django_smalluuid.models.UUIDDefault(), primary_key=True, serialize=False, unique=True)),
                ('name', models.CharField(max_length=100)),                
            ],
        ),
    ]
```
이렇게 보면 일반적으로 파이썬을 다룬 사람이라면 대강 느낌이 온다.
모델(테이블)을 생성해주는 구문이 있구나라고 느껴질 것이다.

여기서 끝이 아니다.
makemigrations는 적용시켜줘야하는 문서를 만들어주는 것이지 실제로 적용된 것이 아니다.
이 기능은 테이블의 변경 이력을 만들어주는 것이라고 생각된다.
나중에 Rollback을 위해서도 이 이력은 삭제하지 않고 가지고 있는 것이 좋다.


## migrate
말 그대로 병합.
만들어둔 migrations폴더에 있는 이력 문서들을 DB에 적용시켜주는 명령이다.
요 명령 때문에 장고 개발자는 DB의 SQL문을 모르더라도 테이블을 수정할 수 있다.

명령어는 간단하다.
```
python manage.py migrate
```
요 한줄이면 끝난다.
아래는 그 출력 결과다.
```
Operations to perform:
  Apply all migrations: model
Running migrations:
  Applying model.0001_initial... OK
```
결과를 보면 두가지에 대해서 결과가 출력된다.
* Operations to perform
migrate를 수행하는 대상(app)이 누구냐 라는 것.
* Running migrations
수행된 migration은 무엇이고 적용 결과는 어떤지를 알려준다.

우린 model이라는 app의 modelA를 적용시켰다. 그러나 결과창에는 단순히 model.0001_initial이 끝이다.
migrations 폴더 안에 있는 저 파일을 적용시켰다는 의미이다.

그런데 화자와 같이 DB에서 직접 제어를 해서 테이블을 날려버렸다면
위 명령이 제대로 수행되지 않을 경우가 있다.
그 이유는 이력상에는 이미 수행되어 있는 경우라고 판단하기 때문으로 보인다.
참고로 이력을 보기 위해서는 다음 명령을 수행하면 된다.
```
python manage.py showmigrations
```
```
model
 [X] 0001_initial
```
이렇게 적용은 되어있는데 다시 migrate를 수행하니 생성이 되지 않는 것이었다.
그래서 이를 해결하기 위해서는 구라(fake)를 좀 쳐줘야 한다.

```
python manage.py migrate --fake model zero
python manage.py migrate model
```
명령어를 보자면 --fake라는 것은 실제 적용하지 않으나 수행해라는 의미이고
model은 migrate를 적용할 app의 이름이다.
마지막 zero는 이력을 제로로 만들어라는 의미로 DB에 적용되어진 이력들을 무효화시키라는 의미다.

저렇게 하면 테이블이 생성된다.
이걸 몰라서 한참을 해맸다.
